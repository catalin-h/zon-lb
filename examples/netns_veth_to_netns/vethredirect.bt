#!/usr/bin/env bpftrace
/*
 * veth redirect - shows veth received packets
 *
 * Adapted for veth after bpftrace tcpdrop.bt.
 */

#ifndef BPFTRACE_HAVE_BTF
#include <linux/socket.h>
#include <net/sock.h>
#else
#include <sys/socket.h>
#endif
#include <linux/ip.h>
#include <linux/ipv6.h>

BEGIN
{
  printf("Tracing veth rx packets. Ctrl-C to end.\n");

  @tcp_states[1] = "ESTABLISHED";
  @tcp_states[2] = "SYN_SENT";
  @tcp_states[3] = "SYN_RECV";
  @tcp_states[4] = "FIN_WAIT1";
  @tcp_states[5] = "FIN_WAIT2";
  @tcp_states[6] = "TIME_WAIT";
  @tcp_states[7] = "CLOSE";
  @tcp_states[8] = "CLOSE_WAIT";
  @tcp_states[9] = "LAST_ACK";
  @tcp_states[10] = "LISTEN";
  @tcp_states[11] = "CLOSING";
  @tcp_states[12] = "NEW_SYN_RECV";
}

// Note: the net namespace is retrieved from the
// skb->dev->nd_net; see ip_local_deliver

 
kprobe:ip_protocol_deliver_rcu
{
  $skb = (struct sk_buff *)arg1;
  $sk = ((struct sock *) $skb->sk);
  $ethertype = bswap($skb->protocol);
  $proto = (int32)arg2;
  $ifname = $skb->dev->name;

  if (strncmp($ifname, "veth", 4)) {
    return;
  }

  time("%H:%M:%S ");
  printf("%-8d %-16s %s ", pid, comm, $ifname);

  if ($ethertype != ETH_P_IP && $ethertype != ETH_P_IPV6) {
    printf("%-24s unknown ethertype: %d , proto: %d\n",
		probe, $ethertype, $proto);
    return;
  }

  if ($ethertype == ETH_P_IP) {
    $iphdr4 = (struct iphdr *)($skb->data + $skb->network_header);
    $daddr = ntop( $iphdr4->daddr);
    $saddr = ntop($iphdr4->saddr);
  } else {
    $iphdr6 = (struct ipv6hdr *)($skb->data + $skb->network_header);
    $daddr  = ntop($iphdr6->daddr.in6_u.u6_addr8);
    $saddr  = ntop($iphdr6->saddr.in6_u.u6_addr8);
  }

  $lport = $sk->__sk_common.skc_num;
  $dport = $sk->__sk_common.skc_dport;

  // Destination port is big endian, it must be flipped
  $dport = bswap($dport);

  $state = $sk->__sk_common.skc_state;
  $statestr = @tcp_states[$state];

  printf("%-24s %19s:%-6d %19s:%-6d %-10s\n", probe, $saddr, $lport, $daddr, $dport, $statestr);
}

kprobe:napi_complete_done,
kprobe:veth_poll
{
  $napi = (struct napi_struct *)arg0;
  $ifname = $napi->dev->name;

  if (strncmp($ifname, "veth", 4)) {
    return;
  }

  time("%H:%M:%S ");
  printf("%-8d %-16s %s %-24s\n", pid, comm, $ifname, probe);
  //printf("%s\n", kstack);
}

tracepoint:net:napi_gro_receive_entry
{
  $skb = (struct sk_buff *)args->skbaddr;
  $sk = ((struct sock *) $skb->sk);
  $inet_family = $sk->__sk_common.skc_family;

  if ($inet_family == AF_INET || $inet_family == AF_INET6) {
  if ($inet_family == AF_INET) {
    $daddr = ntop($sk->__sk_common.skc_daddr);
    $saddr = ntop($sk->__sk_common.skc_rcv_saddr);
  } else {
    $daddr = ntop($sk->__sk_common.skc_v6_daddr.in6_u.u6_addr8);
    $saddr = ntop($sk->__sk_common.skc_v6_rcv_saddr.in6_u.u6_addr8);
  }

  $lport = $sk->__sk_common.skc_num;
  $dport = $sk->__sk_common.skc_dport;

  // Destination port is big endian, it must be flipped
  $dport = bswap($dport);

  $state = $sk->__sk_common.skc_state;
  $statestr = @tcp_states[$state];

  time("%H:%M:%S ");
  printf("%-8d %-16s ", pid, comm);
  printf("%-24s %19s:%-6d %19s:%-6d %-10s\n", probe, $saddr, $lport, $daddr, $dport, $statestr);
  }
}

kprobe:__xdp_build_skb_from_frame
{
  $ndev = (struct net_device *)arg2;
  $ifname = $ndev->name;
  // TODO: print first frame pointer and trace it later in rx functions

  time("%H:%M:%S ");
  printf("%-8d %-16s %s %-24s\n", pid, comm, $ifname, probe);
  //printf("%s\n", kstack);
}

kretprobe:__xdp_build_skb_from_frame
{
  $skb = (struct sk_buff *)retval;
  $sk = ((struct sock *) $skb->sk);
  $inet_family = $sk->__sk_common.skc_family;
  $ifname = $skb->dev->name;

  time("%H:%M:%S ");
  printf("%-8d %-16s %s ", pid, comm, $ifname);

  if ($inet_family != AF_INET && $inet_family != AF_INET6) {
    printf("%-24s unknown inet_family: %d , reval: %p\n",
		probe, $inet_family, retval);
    return;
  }

  if ($inet_family == AF_INET) {
    $daddr = ntop($sk->__sk_common.skc_daddr);
    $saddr = ntop($sk->__sk_common.skc_rcv_saddr);
  } else {
    $daddr = ntop($sk->__sk_common.skc_v6_daddr.in6_u.u6_addr8);
    $saddr = ntop($sk->__sk_common.skc_v6_rcv_saddr.in6_u.u6_addr8);
  }

  $lport = $sk->__sk_common.skc_num;
  $dport = $sk->__sk_common.skc_dport;

  // Destination port is big endian, it must be flipped
  $dport = bswap($dport);

  $state = $sk->__sk_common.skc_state;
  $statestr = @tcp_states[$state];

  printf("%-24s %19s:%-6d %19s:%-6d %-10s\n", probe, $saddr, $lport, $daddr, $dport, $statestr);
}

kprobe:xdp_return_frame,
{
  // TODO: print first frame ptr

  time("%H:%M:%S ");
  printf("%-8d %-16s %-24s\n", pid, comm, probe);
  printf("%s\n", kstack);
}

kprobe:veth_xdp_rcv.constprop.0,
kprobe:veth_xdp_rcv_bulk_skb.constprop.0,
kprobe:veth_xdp_rcv_one
{
  $rq = (struct veth_rq *)arg0;
  $ifname = $rq->dev->name;
  // TODO: print first frame ptr

  time("%H:%M:%S ");
  printf("%-8d %-16s %s %-24s\n", pid, comm, $ifname, probe);
  //printf("%s\n", kstack);
}

kprobe:veth_xdp_xmit
{
  $ndev = (struct net_device *)arg0;
  $ifname = $ndev->name;
  $ndotx = (uint8)arg4;
  // TODO: print first frame pointer and trace it later in rx functions

  time("%H:%M:%S ");
  printf("%-8d %-16s %s %-24s ndtx=%d\n", pid, comm, $ifname, probe, $ndotx);
  //printf("%s\n", kstack);
}

kprobe:veth_xmit
{
  $skb = (struct sk_buff *)arg0;
  $sk = ((struct sock *) $skb->sk);
  $inet_family = $sk->__sk_common.skc_family;

  $ndev = (struct net_device *)arg1;
  $ifname = $ndev->name;

  if ($inet_family == AF_INET || $inet_family == AF_INET6) {
  if ($inet_family == AF_INET) {
    $daddr = ntop($sk->__sk_common.skc_daddr);
    $saddr = ntop($sk->__sk_common.skc_rcv_saddr);
  } else {
    $daddr = ntop($sk->__sk_common.skc_v6_daddr.in6_u.u6_addr8);
    $saddr = ntop($sk->__sk_common.skc_v6_rcv_saddr.in6_u.u6_addr8);
  }

  $lport = $sk->__sk_common.skc_num;
  $dport = $sk->__sk_common.skc_dport;

  // Destination port is big endian, it must be flipped
  $dport = bswap($dport);

  $state = $sk->__sk_common.skc_state;
  $statestr = @tcp_states[$state];

  time("%H:%M:%S ");
  printf("%-8d %-16s ", pid, comm);
  printf("%s %-24s %19s:%-6d %19s:%-6d %-10s\n", $ifname, probe, $saddr, $lport, $daddr, $dport, $statestr);
  //printf("%s\n", kstack);
  }
}

kprobe:veth_xdp_rcv_skb
{
  $rq = (struct veth_rq *)arg0;
  $ifname = $rq->dev->name;

  $skb = (struct sk_buff *)arg1;
  $sk = ((struct sock *) $skb->sk);
  $inet_family = $sk->__sk_common.skc_family;

  if ($inet_family == AF_INET || $inet_family == AF_INET6) {
  if ($inet_family == AF_INET) {
    $daddr = ntop($sk->__sk_common.skc_daddr);
    $saddr = ntop($sk->__sk_common.skc_rcv_saddr);
  } else {
    $daddr = ntop($sk->__sk_common.skc_v6_daddr.in6_u.u6_addr8);
    $saddr = ntop($sk->__sk_common.skc_v6_rcv_saddr.in6_u.u6_addr8);
  }

  $lport = $sk->__sk_common.skc_num;
  $dport = $sk->__sk_common.skc_dport;

  // Destination port is big endian, it must be flipped
  $dport = bswap($dport);

  $state = $sk->__sk_common.skc_state;
  $statestr = @tcp_states[$state];

  time("%H:%M:%S ");
  printf("%-8d %-16s ", pid, comm);
  printf("%s %-24s %19s:%-6d %19s:%-6d %-10s\n", $ifname, probe, $saddr, $lport, $daddr, $dport, $statestr);
  //printf("%s\n", kstack);
  }
}

END
{
  clear(@tcp_states);
}
